#+TITLE: Arch Linux System Notes

* Shrinking a LVM/LUKS partition
** Boot and setup
Boot into your live [[https://archlinux.org/download/][USB flash installation media]].

Decrypt the LUKS volume:
#+begin_src
cryptsetup luksOpen /dev/sda2 cryptdisk
#+end_src

** Resize the Volume
Extend the logical volume =mediavol= in =MyVolGroup= by 10GB and resize
its filesystem all at once
#+begin_src 
lvresize -L +10G --resizefs MyVolGroup/mediavol
#+end_src

Set the size of the logical volume ~mediavol~ in ~MyVolGroup~ to 15G and
resize its file system all at once:
#+begin_src 
lvresize -L 15G --resizefs MyVolGroup/mediavol
#+end_src

If you want to fill all the free space on a volume group, use the
following command:
#+begin_src 
lvresize -l +100%FREE --resizefs MyVolGroup/mediavol
#+end_src

You can run ~fsck~ just to make sure nothing broke:
#+begin_src 
e2fsck -f /dev/vgroup/lvhome
#+end_src



* Changing X org keybindings
** Globaly
Navigate to [[/sudo:root@Cortex:/etc/X11/xorg.conf.d][X org config dir]] and create the file [[/sudo:root@Cortex:/etc/X11/xorg.conf.d/90-custom-kbd.conf][90-custom-kbd.conf]]
then add the following lines:

The lines in this section should be appened to the file after the
~MatchIskeyboard~ line and befor the ~Endsection~ line.

#+begin_src conf-unix
Section "InputClass"
    Identifier "keyboard defaults"
    MatchIsKeyboard "on"
EndSection
#+end_src
 * Swap CapsLock and Control:
    #+begin_src conf-unix
    Option "XkbOptions" "ctrl:swapcaps"
    #+end_src
** Per User 
Swap Left Control and Tab This option is not avalible in [[/usr/share/X11/xkb/rules/base.lst][base.lst]] so
we have to instead create [[~/.Xmodmap][.Xmodmap]] in our $HOME~ directory and add the
appropriate values.

To find keys run the following:
#+begin_src sh
xmodmap -pke | egrep -e '(Tab|Backspace)'
#+end_src

the output is as follows:
#+begin_src conf-unix 
keycode  22 = BackSpace BackSpace BackSpace BackSpace
keycode  23 = Tab ISO_Left_Tab Tab ISO_Left_Tab
#+end_src

now we add the following to our [[~/.Xmodmap][.Xmodmap]] file:
#+begin_src conf-unix
keycode  23= BackSpace BackSpace BackSpace BackSpace
keycode  22 = Tab ISO_Left_Tab Tab ISO_Left_Tab
#+end_src


#+begin_src  sh
xmodmap ~/.Xmodmap
#+end_src

* ZSH

** Arrays
First, I assume that the use of =ls= is just an example. You cannot
parse the output of ls in any shell, because it is ambiguous. Read [[http://mywiki.wooledge.org/ParsingLs][Why
you shouldn't parse the output of ls(1)]] if this is news to you. In any
shell, to obtain a list of files, use wildcards, e.g. ~files=(*)~.

In zsh, like in other shells, the result of [[http://zsh.sourceforge.net/Doc/Release/Expansion.html#Command-Substitution][command substitution]] is
split into words at whitespace characters (more precisely, according
to the value of ~IFS~). (Unlike other shells, the result of command
substitution is not subject to globbing in zsh.) So if the output of
the ~ls~ command is
#+begin_src 
hello world
wibble
#+end_src
then =files=($(ls))= sets the files array to contain 3 elements: hello,
world and wibble.

If the command substitution is in double quotes, then no splitting is
performed. You can perform custom splitting with [[http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion-Flags][parameter extension
flags]]. Use the =@= flag to indicate that the result of the splitting is
to be an array (oddly, you need to keep the expansion in double
quotes, i.e. ="${(@)…}"=, even though the double-quoted string will
expand to multiple words). For splitting, use the =s= flag,
e.g. ="${(@s:,:)…}"= to split at commas; the =f= flag splits at newlines
only.

#+begin_src 
files=("${(@f)$(ls)}")
#+end_src

Note that the proper way to iterate over an array in general is =for f
in $files[@]=, as =$files= strips off empty elements (here, it doesn't
matter because the elements won't be empty).

=print $f= interprets =$f= as a switch if it begins with a =-= and expands
backslashes in =$f=. Use =print -r -- $f=, or =print -rn -- $f= if you don't
want to add a newline after the string.
